<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Splats Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, 'Lucida Console', Monaco, monospace;
            background: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #event-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            pointer-events: all;
            cursor: default;
            outline: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }

        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: #4a9eff;
        }

        #controls p {
            margin: 5px 0;
            font-size: 0.8rem;
            color: #ccc;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover {
            background: #3a8eef;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }

        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #4a9eff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-text {
            font-size: 0.95rem;
            color: #aaa;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="event-overlay" tabindex="0"></div>
    </div>

    <div id="controls">
        <button id="resetCamera">Reset Camera</button>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading splat...</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "@mkkellogg/gaussian-splats-3d": "https://unpkg.com/@mkkellogg/gaussian-splats-3d@0.4.7/build/gaussian-splats-3d.module.js"
        }
    }
    </script>

    <script type="module">
        import * as GaussianSplats3D from '@mkkellogg/gaussian-splats-3d';
        import * as THREE from 'three';

        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        let viewer = null;
        let initialCameraPosition = null;
        let keys = {};
        const moveSpeed = 0.5;

        // Mouse rotation state
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };
        let baseRotation = null;

        async function initViewer() {
            try {
                loading.classList.remove('hidden');
                loadingText.textContent = 'Initializing viewer...';

                // Create viewer with custom FPS-style controls
                // Camera positioned elevated and back, looking down at scene with Y-down orientation
                viewer = new GaussianSplats3D.Viewer({
                    cameraUp: [0, -1, 0],
                    initialCameraPosition: [0, -20, -20],
                    initialCameraLookAt: [0, -10, 0],
                    useBuiltInControls: false,
                    selfDrivenMode: false,
                    dynamicScene: true,
                    rootElement: document.getElementById('container'),
                    ignoreDevicePixelRatio: false,
                    renderMode: GaussianSplats3D.RenderMode.Always,
                    sceneRevealMode: GaussianSplats3D.SceneRevealMode.Gradual,
                    antialiased: true,
                    focalAdjustment: 1.0,
                    logLevel: GaussianSplats3D.LogLevel.None,
                    sharedMemoryForWorkers: false,
                    gpuAcceleratedSort: false
                });

                // Store initial camera position and rotation for reset
                initialCameraPosition = viewer.camera.position.clone();

                // Initialize base rotation from camera's initial quaternion
                baseRotation = viewer.camera.quaternion.clone();

                loadingText.textContent = 'Loading splat data...';

                // Load the PLY file
                await viewer.addSplatScene('IMG_6340.ply', {
                    showLoadingUI: false,
                    progressiveLoad: true,
                    rotation: [0, 0, 0, 1],
                    position: [0, 0, 0],
                    scale: [1, 1, 1]
                });

                loadingText.textContent = 'Starting viewer...';

                // Setup custom FPS-style controls (no viewer.start() needed with selfDrivenMode: false)
                setupControls();

                // Hide loading indicator and focus overlay for keyboard input
                setTimeout(() => {
                    loading.classList.add('hidden');
                    document.getElementById('event-overlay').focus();
                }, 500);

            } catch (error) {
                console.error('Error initializing viewer:', error);
                loadingText.textContent = 'Error loading splat: ' + error.message;
            }
        }

        // Setup FPS-style controls
        function setupControls() {
            const overlay = document.getElementById('event-overlay');

            // Restore focus on click (for keyboard controls)
            overlay.addEventListener('click', () => {
                overlay.focus();
            });

            // Mouse drag to rotate camera
            overlay.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            overlay.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    rotation.y -= deltaX * 0.005;
                    rotation.x -= deltaY * 0.005;

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            overlay.addEventListener('mouseup', (e) => {
                e.preventDefault();
                isDragging = false;
            });

            overlay.addEventListener('mouseleave', () => {
                isDragging = false;
            });

            // Scroll wheel to zoom (move camera forward/backward)
            overlay.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                viewer.camera.translateZ(e.deltaY * zoomSpeed * 0.01);
            }, { passive: false });

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Touch controls for mobile
            let touchStartX = 0;
            let touchStartY = 0;
            let touchStartDistance = 0;

            overlay.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    previousMousePosition = { x: touchStartX, y: touchStartY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                }
                e.preventDefault();
            }, { passive: false });

            overlay.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isDragging) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;

                    // Slower sensitivity for natural touch feel (drag matches finger movement)
                    rotation.y += deltaX * 0.003;
                    rotation.x += deltaY * 0.003;

                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const delta = touchStartDistance - distance;
                    viewer.camera.translateZ(delta * 0.05); // Faster pinch zoom (was 0.01)

                    touchStartDistance = distance;
                }
                e.preventDefault();
            }, { passive: false });

            overlay.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Animation loop for WASD movement and camera rotation
            function animate() {
                requestAnimationFrame(animate);

                if (!viewer || !viewer.camera) return;

                // WASD movement
                if (keys['w']) {
                    viewer.camera.translateZ(-moveSpeed);
                }
                if (keys['s']) {
                    viewer.camera.translateZ(moveSpeed);
                }
                if (keys['a']) {
                    viewer.camera.translateX(-moveSpeed);
                }
                if (keys['d']) {
                    viewer.camera.translateX(moveSpeed);
                }
                if (keys['q'] || keys['shift']) {
                    viewer.camera.translateY(-moveSpeed);
                }
                if (keys['e'] || keys[' ']) {
                    viewer.camera.translateY(moveSpeed);
                }

                // Apply mouse rotation to camera
                const euler = new THREE.Euler(rotation.x, rotation.y, 0, 'YXZ');
                const mouseRotation = new THREE.Quaternion();
                mouseRotation.setFromEuler(euler);
                viewer.camera.quaternion.copy(baseRotation).multiply(mouseRotation);

                // Manually trigger viewer update and render (since selfDrivenMode: false)
                viewer.update();
                viewer.render();
            }
            animate();
        }

        // Reset camera function
        function resetCamera() {
            if (viewer && initialCameraPosition && baseRotation) {
                viewer.camera.position.copy(initialCameraPosition);
                viewer.camera.quaternion.copy(baseRotation);
                rotation = { x: 0, y: 0 };
            }
        }

        // Handle reset button
        document.getElementById('resetCamera').addEventListener('click', resetCamera);

        // Initialize viewer on page load
        initViewer();
    </script>
</body>
</html>
