<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      gap: 20px;
    }
    #legend {
      margin-top: 20px;
    }
    .color-box {
      display: inline-block;
      width: 20px;
      height: 20px;
      vertical-align: middle;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <div id="sketch-holder"></div>
  <div id="legend">
    <p><span class="color-box" style="background-color: white; border: 1px solid black;"></span> Free</p>
    <p><span class="color-box" style="background-color: red;"></span> Allocated</p>
    <p><span class="color-box" style="background-color: blue;"></span> Moving</p>
    <p><span class="color-box" style="background-color: yellow;"></span> Highest Written Block</p>
  </div>

  <script>
    let grid = [];
    let cols = 10;
    let rows = 5;
    let cellSize = 40;
    let state = 'allocate'; // 'allocate', 'free', 'defrag'
    let frameCounter = 0;
    let highestWritten = -1;
    let movingBlocks = []; // {startX, startY, endX, endY, t}

    function setup() {
      let canvas = createCanvas(cols * cellSize, rows * cellSize);
      canvas.parent('sketch-holder');
      for (let y = 0; y < rows; y++) {
        grid[y] = new Array(cols).fill(0);
      }
    }

    function draw() {
      background(220);
      frameCounter++;

      if (frameCounter % 30 === 0 && movingBlocks.length === 0) {
        updateState();
      }

      drawGrid();
      drawMovingBlocks();

      if (highestWritten >= 0) {
        stroke(255, 255, 0);
        strokeWeight(3);
        let x = (highestWritten % cols) * cellSize;
        let y = Math.floor(highestWritten / cols) * cellSize;
        line(x + cellSize, y, x + cellSize, y + cellSize);
      }
    }

    function drawGrid() {
      if (highestWritten < 0) return;
      let maxY = Math.floor(highestWritten / cols);
      let maxX = highestWritten % cols;

      for (let y = 0; y <= maxY; y++) {
        let endX = (y < maxY) ? cols - 1 : maxX;
        for (let x = 0; x <= endX; x++) {
          if (grid[y][x] === 0) {
            fill(255);
          } else if (grid[y][x] === 1) {
            fill(255, 0, 0);
          }
          stroke(0);
          strokeWeight(1);
          rect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
    }

    function drawMovingBlocks() {
      for (let i = movingBlocks.length - 1; i >= 0; i--) {
        let block = movingBlocks[i];
        let t = block.t;
        let x = lerp(block.startX * cellSize, block.endX * cellSize, t);
        let y = lerp(block.startY * cellSize, block.endY * cellSize, t);
        let r = lerp(0, 255, t);
        let b = lerp(255, 0, t);
        fill(r, 0, b);
        stroke(0);
        strokeWeight(1);
        rect(x, y, cellSize, cellSize);

        block.t += 0.05;
        if (block.t >= 1) {
          grid[block.endY][block.endX] = 1;
          movingBlocks.splice(i, 1);
        }
      }
    }

    function updateState() {
      if (state === 'allocate') {
        let nextIdx = highestWritten + 1;
        let totalBlocks = rows * cols;
        if (nextIdx < totalBlocks) {
          let y = Math.floor(nextIdx / cols);
          let x = nextIdx % cols;
          if (grid[y][x] === 0) {
            grid[y][x] = 1;
            highestWritten = nextIdx;
          }
        } else {
          state = 'free';
        }
      } else if (state === 'free') {
        let allocatedSpots = [];
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            if (grid[y][x] === 1) allocatedSpots.push(y * cols + x);
          }
        }
        if (allocatedSpots.length > 0 && random(1) > 0.3) {
          let idx = allocatedSpots[Math.floor(random(allocatedSpots.length))];
          let y = Math.floor(idx / cols);
          let x = idx % cols;
          grid[y][x] = 0;
          highestWritten = -1;
          for (let i = rows * cols - 1; i >= 0; i--) {
            let y = Math.floor(i / cols);
            let x = i % cols;
            if (grid[y][x] === 1) {
              highestWritten = i;
              break;
            }
          }
        } else {
          state = 'defrag';
        }
      } else if (state === 'defrag') {
        // Count gaps and allocated blocks up to highestWritten
        let gaps = [];
        let allocated = [];
        for (let i = 0; i <= highestWritten; i++) {
          let y = Math.floor(i / cols);
          let x = i % cols;
          if (grid[y][x] === 0) gaps.push({x, y});
          else allocated.push({x, y});
        }

        // Only move blocks from the end to fill gaps
        while (gaps.length > 0 && allocated.length > gaps.length) {
          let gap = gaps.shift(); // Take earliest gap
          let block = allocated.pop(); // Take latest block
          if (block.x !== gap.x || block.y !== gap.y) {
            movingBlocks.push({
              startX: block.x,
              startY: block.y,
              endX: gap.x,
              endY: gap.y,
              t: 0
            });
            grid[block.y][block.x] = 0; // Clear source
          }
        }

        // Recalculate highestWritten after moves
        highestWritten = -1;
        for (let i = rows * cols - 1; i >= 0; i--) {
          let y = Math.floor(i / cols);
          let x = i % cols;
          if (grid[y][x] === 1) {
            highestWritten = i;
            break;
          }
        }
        if (movingBlocks.length === 0) state = 'allocate';
      }
    }
  </script>
</body>
</html>